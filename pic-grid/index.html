<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ™ºèƒ½å›¾ç‰‡åˆ‡å›¾å·¥å…·</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        header {
            background: #4a00e0;
            color: white;
            padding: 25px;
            text-align: center;
        }
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        .main-content {
            padding: 20px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 15px;
            background: #f9f9ff;
        }
        .divider {
            height: 2px;
            background: linear-gradient(to right, transparent, #e0e0e0, transparent);
            margin: 30px 0;
        }
        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #4a00e0;
            display: flex;
            align-items: center;
        }
        .section-title::before {
            content: "";
            display: inline-block;
            width: 8px;
            height: 24px;
            background: #4a00e0;
            margin-right: 12px;
            border-radius: 4px;
        }
        .upload-area {
            border: 3px dashed #4a00e0;
            border-radius: 15px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(230, 230, 255, 0.2);
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .upload-area:hover {
            background: rgba(200, 200, 255, 0.3);
            border-color: #8a2be2;
        }
        .upload-icon {
            font-size: 4rem;
            color: #4a00e0;
            margin-bottom: 15px;
        }
        .upload-text {
            font-size: 1.2rem;
            margin-bottom: 15px;
            max-width: 80%;
        }
        .btn {
            background: #4a00e0;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 4px 10px rgba(74, 0, 224, 0.3);
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .btn i {
            margin-right: 8px;
        }
        .btn:hover {
            background: #8a2be2;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(74, 0, 224, 0.4);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .form-row {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .form-group {
            flex: 1;
            min-width: 200px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1.1rem;
            transition: border-color 0.3s;
        }
        input[type="number"]:focus {
            border-color: #4a00e0;
            outline: none;
        }
        .crop-container {
            position: relative;
            margin-top: 20px;
            border: 2px solid #ddd;
            border-radius: 10px;
            overflow: hidden;
            background: #f5f5f5;
            min-height: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #cropCanvas {
            max-width: 100%;
            max-height: 80vh;
            display: block;
            width: auto;
            height: auto;
        }
        .result-container {
            margin-top: 20px;
            position: relative;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 15px;
            min-height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
        }
        .result-grid {
            display: grid;
            background: var(--gap-color, #ffffff);
            border-radius: 5px;
            width: 100%;
            height: 100%;
        }
        .result-image {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 3px;
        }
        .instructions {
            background: #e6f7ff;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid #4a00e0;
        }
        .instructions h3 {
            margin-bottom: 10px;
            color: #4a00e0;
        }
        .instructions ul {
            padding-left: 20px;
        }
        .instructions li {
            margin-bottom: 8px;
        }
        .hidden {
            display: none;
        }
        .loading {
            text-align: center;
            padding: 20px;
        }
        .spinner {
            border: 5px solid rgba(74, 0, 224, 0.2);
            border-top: 5px solid #4a00e0;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .gap-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .gap-color-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .gap-color-btn:hover {
            transform: scale(1.1);
        }
        .gap-color-btn.active {
            border-color: #4a00e0;
            box-shadow: 0 0 0 2px #4a00e0;
        }
        .gap-color-white {
            background-color: white;
        }
        .gap-color-black {
            background-color: black;
        }
        .gap-label {
            font-weight: 600;
            color: #4a00e0;
        }
        footer {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 0.9rem;
            border-top: 1px solid #eee;
        }
        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #4a00e0;
            border: 2px solid white;
            border-radius: 50%;
            cursor: nwse-resize;
            z-index: 10;
        }
        .resize-handle.top-left {
            top: -6px;
            left: -6px;
            cursor: nw-resize;
        }
        .resize-handle.top-right {
            top: -6px;
            right: -6px;
            cursor: ne-resize;
        }
        .resize-handle.bottom-left {
            bottom: -6px;
            left: -6px;
            cursor: sw-resize;
        }
        .resize-handle.bottom-right {
            bottom: -6px;
            right: -6px;
            cursor: se-resize;
        }
        @media (max-width: 768px) {
            .form-row {
                flex-direction: column;
                gap: 15px;
            }
            h1 {
                font-size: 1.8rem;
            }
            .gap-controls {
                flex-wrap: wrap;
            }
            .result-container {
                min-height: 250px;
            }
            .crop-container {
                min-height: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>æ™ºèƒ½å›¾ç‰‡åˆ‡å›¾å·¥å…·</h1>
            <p class="subtitle">ä¸Šä¼ å›¾ç‰‡ï¼ŒæŒ‡å®šè¡Œæ•°ã€åˆ—æ•°å’Œå›¾ç¼æ¯”ä¾‹ï¼Œè‡ªåŠ¨ç”Ÿæˆç½‘æ ¼åˆ‡å›¾</p>
        </header>
        <div class="main-content">
            <div class="section">
                <h2 class="section-title">1. ä¸Šä¼ å›¾ç‰‡</h2>
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">ğŸ“</div>
                    <p class="upload-text">ç‚¹å‡»é€‰æ‹©å›¾ç‰‡æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„</p>
                    <button class="btn" id="selectBtn">
                        <i>ğŸ“¤</i> é€‰æ‹©æ–‡ä»¶
                    </button>
                    <input type="file" id="fileInput" accept="image/*" class="hidden">
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="rows">è¡Œæ•° (é»˜è®¤: 3)</label>
                        <input type="number" id="rows" min="1" max="20" value="3">
                    </div>
                    <div class="form-group">
                        <label for="cols">åˆ—æ•° (é»˜è®¤: 2)</label>
                        <input type="number" id="cols" min="1" max="20" value="2">
                    </div>
                </div>
                <div class="form-group">
                    <label for="ratio">å›¾ç¼æ¯”ä¾‹ (å›¾:ç¼, é»˜è®¤: 30:1ï¼Œ0ä¸ºæ— ç¼)</label>
                    <input type="number" id="ratio" min="0" max="100" value="30">
                </div>
                <button class="btn" id="processBtn" disabled>
                    <i>âš™ï¸</i> å¤„ç†å›¾ç‰‡
                </button>
                <div class="instructions">
                    <h3>ä½¿ç”¨è¯´æ˜</h3>
                    <ul>
                        <li>ä¸Šä¼ PNGã€JPGç­‰æ ¼å¼å›¾ç‰‡ï¼ˆæ”¯æŒé€æ˜èƒŒæ™¯ï¼‰</li>
                        <li>ç³»ç»Ÿä¼šæ ¹æ®è¡Œæ•°ã€åˆ—æ•°å’Œå›¾ç¼æ¯”ä¾‹è®¡ç®—æ‰€éœ€é•¿å®½æ¯”</li>
                        <li>è£å‰ªæ—¶è¯·ä¿æŒå›ºå®šæ¯”ä¾‹ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å®Œæˆåç»­åˆ‡å›¾</li>
                        <li>é•¿æŒ‰ç»“æœå›¾ç‰‡å¯ä¿å­˜åˆ°è®¾å¤‡</li>
                    </ul>
                </div>
            </div>
            <div class="divider"></div>
            <div class="section">
                <h2 class="section-title">2. è£å‰ªå›¾ç‰‡</h2>
                <div class="crop-container" id="cropContainer">
                    <canvas id="cropCanvas"></canvas>
                </div>
                <button class="btn" id="cropBtn" disabled>
                    <i>âœ‚ï¸</i> è£å‰ªå¹¶ç”Ÿæˆ
                </button>
            </div>
            <div class="divider"></div>
            <div class="section">
                <h2 class="section-title">3. åˆ‡å›¾ç»“æœ</h2>
                <div class="result-container" id="resultContainer">
                    <p>è£å‰ªå¹¶ç”Ÿæˆåï¼Œåˆ‡å›¾ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</p>
                </div>
                <div class="gap-controls">
                    <span class="gap-label">ç¼éš™é¢œè‰²:</span>
                    <div class="gap-color-btn gap-color-white active" data-color="white"></div>
                    <div class="gap-color-btn gap-color-black" data-color="black"></div>
                </div>
                <div class="instructions">
                    <h3>ä¿å­˜å›¾ç‰‡</h3>
                    <p>åœ¨æ‰‹æœºä¸Šï¼šé•¿æŒ‰å›¾ç‰‡é€‰æ‹©"ä¿å­˜å›¾åƒ"</p>
                    <p>åœ¨ç”µè„‘ä¸Šï¼šå³é”®ç‚¹å‡»å›¾ç‰‡é€‰æ‹©"å¦å­˜ä¸º"</p>
                </div>
            </div>
        </div>
        <footer>
            <p>Â© 2025 æ™ºèƒ½å›¾ç‰‡åˆ‡å›¾å·¥å…· | æ‰€æœ‰å›¾ç‰‡å¤„ç†å‡åœ¨æœ¬åœ°å®Œæˆï¼Œä¸ä¼šä¸Šä¼ åˆ°æœåŠ¡å™¨</p>
        </footer>
    <script>
        let originalImage = null;
        let cropCanvas = null;
        let cropCtx = null;
        let targetAspectRatio = 0;
        let isDragging = false;
        let isResizing = false;
        let resizeHandle = null;
        let dragStart = {x: 0, y: 0};
        let currentRect = {x: 0, y: 0, width: 0, height: 0};
        let gridInfo = {rows: 3, cols: 2, ratio: 30, gapColor: 'white'};
        let cropContainer = null;
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const selectBtn = document.getElementById('selectBtn');
        const processBtn = document.getElementById('processBtn');
        const cropBtn = document.getElementById('cropBtn');
        const rowsInput = document.getElementById('rows');
        const colsInput = document.getElementById('cols');
        const ratioInput = document.getElementById('ratio');
        const resultContainer = document.getElementById('resultContainer');
        const cropCanvasElement = document.getElementById('cropCanvas');
        const gapColorBtns = document.querySelectorAll('.gap-color-btn');
        cropCanvas = cropCanvasElement;
        cropCtx = cropCanvas.getContext('2d');
        cropContainer = document.getElementById('cropContainer');
        fileInput.addEventListener('change', handleImageUpload);
        uploadArea.addEventListener('click', () => fileInput.click());        uploadArea.addEventListener('dragover', handleDragOver);
        uploadArea.addEventListener('drop', handleDrop);
        processBtn.addEventListener('click', processImage);
        cropBtn.addEventListener('click', generateResult);
        gapColorBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                gapColorBtns.forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                gridInfo.gapColor = this.dataset.color;
                updateResultGrid();
            });
        });
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    processBtn.disabled = false;
                    uploadArea.innerHTML = `<img src="${event.target.result}" style="max-width:100%; max-height:200px; border-radius:10px;">`;
                    uploadArea.addEventListener('click', () => fileInput.click());
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            uploadArea.style.borderColor = '#8a2be2';
            uploadArea.style.backgroundColor = 'rgba(200, 200, 255, 0.4)';
        }
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            uploadArea.style.borderColor = '#4a00e0';
            uploadArea.style.backgroundColor = 'rgba(230, 230, 255, 0.2)';
            const file = e.dataTransfer.files[0];
            if (!file || !file.type.match('image.*')) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    processBtn.disabled = false;
                    uploadArea.innerHTML = `<img src="${event.target.result}" style="max-width:100%; max-height:200px; border-radius:10px;">`;
                    uploadArea.addEventListener('click', () => fileInput.click());
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }
        function processImage() {
            if (!originalImage) {
                alert('è¯·å…ˆä¸Šä¼ å›¾ç‰‡');
                return;
            }
            gridInfo.rows = parseInt(rowsInput.value) || 3;
            gridInfo.cols = parseInt(colsInput.value) || 2;
            gridInfo.ratio = parseInt(ratioInput.value);
            if (!gridInfo.ratio && gridInfo.ratio !== 0) {
                gridInfo.ratio = 30;
            }
            if (gridInfo.ratio === 0) {
                targetAspectRatio = gridInfo.cols / gridInfo.rows;
            } else {
                const horizontal = gridInfo.cols * gridInfo.ratio + (gridInfo.cols - 1);
                const vertical = gridInfo.rows * gridInfo.ratio + (gridInfo.rows - 1);
                targetAspectRatio = horizontal / vertical;
            }
            const containerWidth = cropContainer.clientWidth;
            const containerHeight = Math.min(cropContainer.clientHeight, window.innerHeight * 0.6);
            let canvasWidth = originalImage.width;
            let canvasHeight = originalImage.height;
            if (canvasWidth > containerWidth || canvasHeight > containerHeight) {
                const ratioW = containerWidth / canvasWidth;
                const ratioH = containerHeight / canvasHeight;
                const scale = Math.min(ratioW, ratioH);
                canvasWidth = Math.floor(canvasWidth * scale);
                canvasHeight = Math.floor(canvasHeight * scale);
            }
            
            cropCanvas.width = canvasWidth;
            cropCanvas.height = canvasHeight;
            cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropCtx.drawImage(originalImage, 0, 0, canvasWidth, canvasHeight);
            let cropWidth, cropHeight;
            if (gridInfo.ratio === 0) {
                cropWidth = Math.min(canvasWidth, canvasHeight * targetAspectRatio);
                cropHeight = cropWidth / targetAspectRatio;
            } else {
                cropWidth = Math.min(canvasWidth, canvasHeight * targetAspectRatio);
                cropHeight = cropWidth / targetAspectRatio;
            }
            if (cropWidth <= 1) cropWidth = 1;
            if (cropHeight <= 1) cropHeight = 1;
            
            currentRect = {
                x: (canvasWidth - cropWidth) / 2,
                y: (canvasHeight - cropHeight) / 2,
                width: cropWidth,
                height: cropHeight
            };
            if (currentRect.x < 0) currentRect.x = 0;
            if (currentRect.y < 0) currentRect.y = 0;
            if (currentRect.x + currentRect.width > canvasWidth) {
                currentRect.width = canvasWidth - currentRect.x;
            }
            if (currentRect.y + currentRect.height > canvasHeight) {
                currentRect.height = canvasHeight - currentRect.y;
            }
            drawCropRect();
            cropBtn.disabled = false;
            createResizeHandles();
        }
        function createResizeHandles() {
            const existingHandles = cropContainer.querySelectorAll('.resize-handle');
            existingHandles.forEach(handle => handle.remove());
            const positions = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
            positions.forEach(pos => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${pos}`;
                handle.dataset.handle = pos;
                cropContainer.appendChild(handle);
                handle.addEventListener('mousedown', startResize);
                handle.addEventListener('touchstart', startResize);
            });
            updateHandlesPosition();
        }
        function updateHandlesPosition() {
            const handles = cropContainer.querySelectorAll('.resize-handle');
            handles.forEach(handle => {
                const rect = cropCanvas.getBoundingClientRect();
                const containerRect = cropContainer.getBoundingClientRect();
                const x = currentRect.x + rect.left - containerRect.left;
                const y = currentRect.y + rect.top - containerRect.top;
                const width = currentRect.width;
                const height = currentRect.height;
                if (handle.classList.contains('top-left')) {
                    handle.style.left = (x - 6) + 'px';
                    handle.style.top = (y - 6) + 'px';
                } else if (handle.classList.contains('top-right')) {
                    handle.style.right = (containerRect.width - (x + width) - 6) + 'px';
                    handle.style.top = (y - 6) + 'px';
                } else if (handle.classList.contains('bottom-left')) {
                    handle.style.left = (x - 6) + 'px';
                    handle.style.bottom = (containerRect.height - (y + height) - 6) + 'px';
                } else if (handle.classList.contains('bottom-right')) {
                    handle.style.right = (containerRect.width - (x + width) - 6) + 'px';
                    handle.style.bottom = (containerRect.height - (y + height) - 6) + 'px';
                }
            });
        }
        function drawCropRect() {
            cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropCtx.drawImage(originalImage, 0, 0, cropCanvas.width, cropCanvas.height);
            cropCtx.strokeStyle = '#4a00e0';
            cropCtx.lineWidth = 2;
            cropCtx.setLineDash([10, 5]);
            cropCtx.strokeRect(
                currentRect.x,
                currentRect.y,
                currentRect.width,
                currentRect.height
            );
            cropCtx.setLineDash([]);
            if (currentRect.width > 0 && currentRect.height > 0 && gridInfo.ratio !== 0) {
                const totalHorizontal = gridInfo.cols * gridInfo.ratio + (gridInfo.cols - 1);
                const totalVertical = gridInfo.rows * gridInfo.ratio + (gridInfo.rows - 1);
                const cellWidth = (currentRect.width / totalHorizontal) * gridInfo.ratio;
                const cellHeight = (currentRect.height / totalVertical) * gridInfo.ratio;
                const gap = currentRect.width / totalHorizontal;                cropCtx.strokeStyle = 'rgba(74, 0, 224, 0.5)';
                cropCtx.lineWidth = 1;
                cropCtx.setLineDash([3, 3]);
                let xPos = currentRect.x;
                for (let col = 0; col < gridInfo.cols; col++) {
                    xPos += cellWidth;
                    cropCtx.beginPath();
                    cropCtx.moveTo(xPos, currentRect.y);
                    cropCtx.lineTo(xPos, currentRect.y + currentRect.height);
                    cropCtx.stroke();
                    if (col < gridInfo.cols - 1) {
                        xPos += gap;
                        cropCtx.beginPath();
                        cropCtx.moveTo(xPos, currentRect.y);
                        cropCtx.lineTo(xPos, currentRect.y + currentRect.height);
                        cropCtx.stroke();
                    }
                }
                let yPos = currentRect.y;
                for (let row = 0; row < gridInfo.rows; row++) {
                    yPos += cellHeight;
                    cropCtx.beginPath();
                    cropCtx.moveTo(currentRect.x, yPos);
                    cropCtx.lineTo(currentRect.x + currentRect.width, yPos);
                    cropCtx.stroke();
                    if (row < gridInfo.rows - 1) {
                        yPos += gap;
                        cropCtx.beginPath();
                        cropCtx.moveTo(currentRect.x, yPos);
                        cropCtx.lineTo(currentRect.x + currentRect.width, yPos);
                        cropCtx.stroke();
                    }
                }
                cropCtx.setLineDash([]);
            } else if (currentRect.width > 0 && currentRect.height > 0 && gridInfo.ratio === 0) {
                cropCtx.strokeStyle = 'rgba(74, 0, 224, 0.5)';
                cropCtx.lineWidth = 1;
                cropCtx.setLineDash([3, 3]);
                for (let i = 1; i < gridInfo.cols; i++) {
                    const x = currentRect.x + (currentRect.width / gridInfo.cols) * i;
                    cropCtx.beginPath();
                    cropCtx.moveTo(x, currentRect.y);
                    cropCtx.lineTo(x, currentRect.y + currentRect.height);
                    cropCtx.stroke();
                }
                for (let i = 1; i < gridInfo.rows; i++) {
                    const y = currentRect.y + (currentRect.height / gridInfo.rows) * i;
                    cropCtx.beginPath();
                    cropCtx.moveTo(currentRect.x, y);
                    cropCtx.lineTo(currentRect.x + currentRect.width, y);
                    cropCtx.stroke();
                }
                cropCtx.setLineDash([]);
            }
            updateHandlesPosition();
        }
        function startDrag(e) {
            const rect = cropCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (x >= currentRect.x && x <= currentRect.x + currentRect.width &&
                y >= currentRect.y && y <= currentRect.y + currentRect.height) {
                isDragging = true;
                dragStart.x = x - currentRect.x;
                dragStart.y = y - currentRect.y;
                cropCanvas.style.cursor = 'move';
                e.preventDefault();
            }
        }
        function doDrag(e) {
            if (!isDragging) return;
            const rect = cropCanvas.getBoundingClientRect();
            let x = e.clientX - rect.left - dragStart.x;
            let y = e.clientY - rect.top - dragStart.y;
            x = Math.max(0, Math.min(x, cropCanvas.width - currentRect.width));
            y = Math.max(0, Math.min(y, cropCanvas.height - currentRect.height));
            currentRect.x = x;
            currentRect.y = y;
            drawCropRect();
            e.preventDefault();
        }
        function endDrag() {
            isDragging = false;
            cropCanvas.style.cursor = 'default';
        }
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = cropCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            if (x >= currentRect.x && x <= currentRect.x + currentRect.width &&
                y >= currentRect.y && y <= currentRect.y + currentRect.height) {
                isDragging = true;
                dragStart.x = x - currentRect.x;
                dragStart.y = y - currentRect.y;
            }
        }
        function handleTouchMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = cropCanvas.getBoundingClientRect();
            let x = touch.clientX - rect.left - dragStart.x;
            let y = touch.clientY - rect.top - dragStart.y;
            x = Math.max(0, Math.min(x, cropCanvas.width - currentRect.width));
            y = Math.max(0, Math.min(y, cropCanvas.height - currentRect.height));
            currentRect.x = x;
            currentRect.y = y;
            drawCropRect();
        }
        function handleTouchEnd(e) {
            isDragging = false;
        }
        function startResize(e) {
            e.preventDefault();
            isResizing = true;
            resizeHandle = e.target.dataset.handle;
            dragStart.x = e.clientX || e.touches[0].clientX;
            dragStart.y = e.clientY || e.touches[0].clientY;
            cropCanvas.style.cursor = getResizeCursor(resizeHandle);
        }
        function doResize(e) {
            if (!isResizing) return;
            const rect = cropCanvas.getBoundingClientRect();
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            const deltaX = clientX - dragStart.x;
            const deltaY = clientY - dragStart.y;
            let newWidth = currentRect.width;
            let newHeight = currentRect.height;
            let newX = currentRect.x;
            let newY = currentRect.y;
            if (resizeHandle === 'bottom-right') {
                newWidth = currentRect.width + deltaX;
                newHeight = currentRect.height + deltaY;
            } else if (resizeHandle === 'bottom-left') {
                newWidth = currentRect.width - deltaX;
                newHeight = currentRect.height + deltaY;
                newX = currentRect.x + currentRect.width - newWidth;
            } else if (resizeHandle === 'top-right') {
                newWidth = currentRect.width + deltaX;
                newHeight = currentRect.height - deltaY;
                newY = currentRect.y + currentRect.height - newHeight;
            } else if (resizeHandle === 'top-left') {
                newWidth = currentRect.width - deltaX;
                newHeight = currentRect.height - deltaY;
                newX = currentRect.x + currentRect.width - newWidth;
                newY = currentRect.y + currentRect.height - newHeight;
            }
            if (resizeHandle === 'bottom-right' || resizeHandle === 'top-left') {
                newHeight = newWidth / targetAspectRatio;
                if (resizeHandle === 'top-left') {
                    newY = currentRect.y + currentRect.height - newHeight;
                }
            } else {
                newWidth = newHeight * targetAspectRatio;
                if (resizeHandle === 'bottom-left' || resizeHandle === 'top-left') {
                    newX = currentRect.x + currentRect.width - newWidth;
                }
            }
            let corrected = false;
            if (newX + newWidth > cropCanvas.width) {
                newWidth = cropCanvas.width - newX;
                newHeight = newWidth / targetAspectRatio;
                corrected = true;
            }
            if (newY + newHeight > cropCanvas.height) {
                newHeight = cropCanvas.height - newY;
                newWidth = newHeight * targetAspectRatio;
                corrected = true;
            }
            if (newX < 0) {
                newX = 0;
                if (newX + newWidth > cropCanvas.width) {
                    newWidth = cropCanvas.width;
                    newHeight = newWidth / targetAspectRatio;
                }
                corrected = true;
            }
            if (newY < 0) {
                newY = 0;
                if (newY + newHeight > cropCanvas.height) {
                    newHeight = cropCanvas.height;
                    newWidth = newHeight * targetAspectRatio;
                }
                corrected = true;
            }
            if (corrected) {
                if (resizeHandle === 'bottom-left' || resizeHandle === 'top-left') {
                    newX = currentRect.x + currentRect.width - newWidth;
                    if (newX < 0) newX = 0;
                }
                if (resizeHandle === 'top-right' || resizeHandle === 'top-left') {
                    newY = currentRect.y + currentRect.height - newHeight;
                    if (newY < 0) newY = 0;
                }
            }
            if (newWidth <= 1) newWidth = 1;
            if (newHeight <= 1) newHeight = 1;
            if (newX < 0) newX = 0;
            if (newY < 0) newY = 0;
            if (newX + newWidth > cropCanvas.width) {
                newWidth = cropCanvas.width - newX;
            }
            if (newY + newHeight > cropCanvas.height) {
                newHeight = cropCanvas.height - newY;
            }
            currentRect = {x: newX, y: newY, width: newWidth, height: newHeight};
            drawCropRect();
            dragStart.x = clientX;
            dragStart.y = clientY;
        }
        function endResize() {
            isResizing = false;
            resizeHandle = null;
            cropCanvas.style.cursor = 'default';
        }
        function getResizeCursor(handle) {
            const cursors = {
                'top-left': 'nw-resize',
                'top-right': 'ne-resize',
                'bottom-left': 'sw-resize',
                'bottom-right': 'se-resize'
            };
            return cursors[handle] || 'default';
        }
        cropCanvas.addEventListener('mousedown', startDrag);
        cropCanvas.addEventListener('mousemove', doDrag);
        cropCanvas.addEventListener('mouseup', endDrag);
        cropCanvas.addEventListener('mouseleave', endDrag);
        cropCanvas.addEventListener('touchstart', handleTouchStart);
        cropCanvas.addEventListener('touchmove', handleTouchMove);
        cropCanvas.addEventListener('touchend', handleTouchEnd);
        cropContainer.addEventListener('mousemove', (e) => {
            if (isResizing) doResize(e);
        });
        cropContainer.addEventListener('mouseup', endResize);
        cropContainer.addEventListener('mouseleave', endResize);
        cropContainer.addEventListener('touchmove', (e) => {
            if (isResizing) doResize(e);
        });
        cropContainer.addEventListener('touchend', endResize);
        function generateResult() {
            if (!originalImage || !currentRect.width || !currentRect.height) {
                alert('è¯·å…ˆå¤„ç†å›¾ç‰‡å¹¶è°ƒæ•´è£å‰ªåŒºåŸŸ');
                return;
            }
            resultContainer.innerHTML = '<div class="loading"><div class="spinner"></div><p>æ­£åœ¨ç”Ÿæˆåˆ‡å›¾...</p></div>';
            const croppedCanvas = document.createElement('canvas');
            const croppedCtx = croppedCanvas.getContext('2d');
            const scaleX = originalImage.width / cropCanvas.width;
            const scaleY = originalImage.height / cropCanvas.height;
            const actualWidth = currentRect.width * scaleX;
            const actualHeight = currentRect.height * scaleY;
            croppedCanvas.width = actualWidth;
            croppedCanvas.height = actualHeight;
            croppedCtx.drawImage(
                originalImage,
                currentRect.x * scaleX,
                currentRect.y * scaleY,
                actualWidth,
                actualHeight,
                0, 0,
                actualWidth,
                actualHeight
            );
            let finalWidth, finalHeight, cellPixelSize, gapSize;
            if (gridInfo.ratio === 0) {
                cellPixelSize = Math.floor(Math.min(actualWidth / gridInfo.cols, actualHeight / gridInfo.rows));
                finalWidth = cellPixelSize * gridInfo.cols;
                finalHeight = cellPixelSize * gridInfo.rows;
                gapSize = 0;
            } else {
                const cellSize = Math.min(
                    actualWidth / (gridInfo.cols * gridInfo.ratio + gridInfo.cols - 1),
                    actualHeight / (gridInfo.rows * gridInfo.ratio + gridInfo.rows - 1)
                );
                const intCellSize = Math.max(1, Math.floor(cellSize));
                finalWidth = intCellSize * (gridInfo.cols * gridInfo.ratio + gridInfo.cols - 1);
                finalHeight = intCellSize * (gridInfo.rows * gridInfo.ratio + gridInfo.rows - 1);
                cellPixelSize = intCellSize * gridInfo.ratio;
                gapSize = intCellSize;
            }
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = finalWidth;
            finalCanvas.height = finalHeight;
            const finalCtx = finalCanvas.getContext('2d');
            finalCtx.drawImage(croppedCanvas, 0, 0, finalWidth, finalHeight);
            const cellImages = [];
            for (let row = 0; row < gridInfo.rows; row++) {
                for (let col = 0; col < gridInfo.cols; col++) {
                    let x, y;
                    if (gridInfo.ratio === 0) {
                        x = col * cellPixelSize;
                        y = row * cellPixelSize;
                    } else {
                        x = col * (cellPixelSize + gapSize);
                        y = row * (cellPixelSize + gapSize);
                    }
                    const cellCanvas = document.createElement('canvas');
                    cellCanvas.width = cellPixelSize;
                    cellCanvas.height = cellPixelSize;
                    const cellCtx = cellCanvas.getContext('2d');
                    cellCtx.drawImage(
                        finalCanvas,
                        x, y,
                        cellPixelSize, cellPixelSize,
                        0, 0,
                        cellPixelSize, cellPixelSize
                    );
                    const img = new Image();
                    img.src = cellCanvas.toDataURL('image/png');
                    cellImages.push(img);
                }
            }
            displayResults(cellImages, cellPixelSize, gapSize);
        }
        function displayResults(images, cellSize, gapSize) {
            resultContainer.innerHTML = '';
            const grid = document.createElement('div');
            grid.className = 'result-grid';
            if (gridInfo.ratio === 0) {
                grid.style.aspectRatio = `${gridInfo.cols}/${gridInfo.rows}`;
                grid.style.gap = "0%";
                grid.style.padding = "2.5%";
                grid.style.boxSizing = 'content-box';
                grid.style.gridTemplateColumns = `repeat(${gridInfo.cols}, 1fr)`;
                grid.style.gridTemplateRows = `repeat(${gridInfo.rows}, 1fr)`;
            } else {
                const horizontalTotal = gridInfo.cols * gridInfo.ratio + (gridInfo.cols - 1);
                const verticalTotal = gridInfo.rows * gridInfo.ratio + (gridInfo.rows - 1);
                grid.style.aspectRatio = `${horizontalTotal}/${verticalTotal}`;
                const horizontalGapPercent = (1 / horizontalTotal * 100);
                const verticalGapPercent = (1 / verticalTotal * 100);
                grid.style.gap = `${verticalGapPercent}% ${horizontalGapPercent}%`;
                grid.style.padding = `${horizontalGapPercent}%`;
                grid.style.boxSizing = 'content-box';
                grid.style.gridTemplateColumns = `repeat(${gridInfo.cols}, 1fr)`;
                grid.style.gridTemplateRows = `repeat(${gridInfo.rows}, 1fr)`;
            }
            grid.style.setProperty('--gap-color', gridInfo.gapColor === 'white' ? '#ffffff' : '#000000');
            images.forEach(img => {
                const cell = document.createElement('div');
                img.className = 'result-image';
                cell.appendChild(img);
                cell.classList.add('result-cell');
                grid.appendChild(cell);
            });
            resultContainer.appendChild(grid);
            resultContainer.style.overflow = 'auto';
        }
        function updateResultGrid() {
            const grid = resultContainer.querySelector('.result-grid');
            if (grid) {
                grid.style.setProperty('--gap-color', gridInfo.gapColor === 'white' ? '#ffffff' : '#000000');
            }
        }
        window.addEventListener('resize', () => {
            if (originalImage && currentRect.width > 0) {
                processImage();
            }
        });
    </script>
</body>
</html>
