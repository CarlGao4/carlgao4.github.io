<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½å›¾ç‰‡åˆ‡å›¾å·¥å…·</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: #4a00e0;
            color: white;
            padding: 25px;
            text-align: center;
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            padding: 20px;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 15px;
            background: #f9f9ff;
        }

        .divider {
            height: 2px;
            background: linear-gradient(to right, transparent, #e0e0e0, transparent);
            margin: 30px 0;
        }

        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #4a00e0;
            display: flex;
            align-items: center;
        }

        .section-title::before {
            content: "";
            display: inline-block;
            width: 8px;
            height: 24px;
            background: #4a00e0;
            margin-right: 12px;
            border-radius: 4px;
        }

        .upload-area {
            border: 3px dashed #4a00e0;
            border-radius: 15px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(230, 230, 255, 0.2);
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .upload-area:hover {
            background: rgba(200, 200, 255, 0.3);
            border-color: #8a2be2;
        }

        .upload-icon {
            font-size: 4rem;
            color: #4a00e0;
            margin-bottom: 15px;
        }

        .upload-text {
            font-size: 1.2rem;
            margin-bottom: 15px;
            max-width: 80%;
        }

        .btn {
            background: #4a00e0;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 4px 10px rgba(74, 0, 224, 0.3);
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .btn i {
            margin-right: 8px;
        }

        .btn:hover {
            background: #8a2be2;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(74, 0, 224, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .form-row {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .form-group {
            flex: 1;
            min-width: 200px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1.1rem;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus {
            border-color: #4a00e0;
            outline: none;
        }

        .crop-container {
            position: relative;
            margin-top: 20px;
            border: 2px solid #ddd;
            border-radius: 10px;
            overflow: hidden;
            background: #f5f5f5;
            min-height: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #cropCanvas {
            max-width: 100%;
            max-height: 80vh;
            display: block;
            width: auto;
            height: auto;
        }

        .result-container {
            margin-top: 20px;
            position: relative;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 15px;
            min-height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
        }

        .result-grid {
            display: grid;
            background: var(--gap-color, #ffffff);
            border-radius: 5px;
            width: 100%;
            height: 100%;
        }

        .result-image {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 3px;
        }

        .instructions {
            background: #e6f7ff;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid #4a00e0;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #4a00e0;
        }

        .instructions ul {
            padding-left: 20px;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        .hidden {
            display: none;
        }

        .loading {
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 5px solid rgba(74, 0, 224, 0.2);
            border-top: 5px solid #4a00e0;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .gap-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .gap-color-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .gap-color-btn:hover {
            transform: scale(1.1);
        }

        .gap-color-btn.active {
            border-color: #4a00e0;
            box-shadow: 0 0 0 2px #4a00e0;
        }

        .gap-color-white {
            background-color: white;
        }

        .gap-color-black {
            background-color: black;
        }

        .gap-label {
            font-weight: 600;
            color: #4a00e0;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 0.9rem;
            border-top: 1px solid #eee;
        }

        /* è£å‰ªæ‰‹æŸ„ */
        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #4a00e0;
            border: 2px solid white;
            border-radius: 50%;
            cursor: nwse-resize;
            z-index: 10;
        }

        .resize-handle.top-left {
            top: -6px;
            left: -6px;
            cursor: nw-resize;
        }

        .resize-handle.top-right {
            top: -6px;
            right: -6px;
            cursor: ne-resize;
        }

        .resize-handle.bottom-left {
            bottom: -6px;
            left: -6px;
            cursor: sw-resize;
        }

        .resize-handle.bottom-right {
            bottom: -6px;
            right: -6px;
            cursor: se-resize;
        }

        @media (max-width: 768px) {
            .form-row {
                flex-direction: column;
                gap: 15px;
            }

            h1 {
                font-size: 1.8rem;
            }

            .gap-controls {
                flex-wrap: wrap;
            }

            .result-container {
                min-height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>æ™ºèƒ½å›¾ç‰‡åˆ‡å›¾å·¥å…·</h1>
            <p class="subtitle">ä¸Šä¼ å›¾ç‰‡ï¼ŒæŒ‡å®šè¡Œæ•°ã€åˆ—æ•°å’Œå›¾ç¼æ¯”ä¾‹ï¼Œè‡ªåŠ¨ç”Ÿæˆç½‘æ ¼åˆ‡å›¾</p>
        </header>

        <div class="main-content">
            <!-- ä¸Šä¼ åŒºåŸŸ -->
            <div class="section">
                <h2 class="section-title">1. ä¸Šä¼ å›¾ç‰‡</h2>
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">ğŸ“</div>
                    <p class="upload-text">ç‚¹å‡»é€‰æ‹©å›¾ç‰‡æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„</p>
                    <button class="btn" id="selectBtn">
                        <i>ğŸ“¤</i> é€‰æ‹©æ–‡ä»¶
                    </button>
                    <input type="file" id="fileInput" accept="image/*" class="hidden">
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="rows">è¡Œæ•° (é»˜è®¤: 3)</label>
                        <input type="number" id="rows" min="1" max="20" value="3">
                    </div>

                    <div class="form-group">
                        <label for="cols">åˆ—æ•° (é»˜è®¤: 2)</label>
                        <input type="number" id="cols" min="1" max="20" value="2">
                    </div>
                </div>

                <div class="form-group">
                    <label for="ratio">å›¾ç¼æ¯”ä¾‹ (å›¾:ç¼, é»˜è®¤: 30:1ï¼Œ0ä¸ºæ— ç¼)</label>
                    <input type="number" id="ratio" min="0" max="100" value="30">
                </div>

                <button class="btn" id="processBtn" disabled>
                    <i>âš™ï¸</i> å¤„ç†å›¾ç‰‡
                </button>

                <div class="instructions">
                    <h3>ä½¿ç”¨è¯´æ˜</h3>
                    <ul>
                        <li>ä¸Šä¼ PNGã€JPGç­‰æ ¼å¼å›¾ç‰‡ï¼ˆæ”¯æŒé€æ˜èƒŒæ™¯ï¼‰</li>
                        <li>ç³»ç»Ÿä¼šæ ¹æ®è¡Œæ•°ã€åˆ—æ•°å’Œå›¾ç¼æ¯”ä¾‹è®¡ç®—æ‰€éœ€é•¿å®½æ¯”</li>
                        <li>è£å‰ªæ—¶è¯·ä¿æŒå›ºå®šæ¯”ä¾‹ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å®Œæˆåç»­åˆ‡å›¾</li>
                        <li>é•¿æŒ‰ç»“æœå›¾ç‰‡å¯ä¿å­˜åˆ°è®¾å¤‡</li>
                    </ul>
                </div>
            </div>

            <div class="divider"></div>

            <!-- è£å‰ªåŒºåŸŸ -->
            <div class="section">
                <h2 class="section-title">2. è£å‰ªå›¾ç‰‡</h2>
                <div class="crop-container" id="cropContainer">
                    <canvas id="cropCanvas"></canvas>
                    <!-- è£å‰ªæ‰‹æŸ„å°†é€šè¿‡JSåŠ¨æ€æ·»åŠ  -->
                </div>
                <button class="btn" id="cropBtn" disabled>
                    <i>âœ‚ï¸</i> è£å‰ªå¹¶ç”Ÿæˆ
                </button>
            </div>

            <div class="divider"></div>

            <!-- ç»“æœå±•ç¤ºåŒºåŸŸ -->
            <div class="section">
                <h2 class="section-title">3. åˆ‡å›¾ç»“æœ</h2>
                <div class="result-container" id="resultContainer">
                    <p>è£å‰ªå¹¶ç”Ÿæˆåï¼Œåˆ‡å›¾ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</p>
                </div>

                <div class="gap-controls">
                    <span class="gap-label">ç¼éš™é¢œè‰²:</span>
                    <div class="gap-color-btn gap-color-white active" data-color="white"></div>
                    <div class="gap-color-btn gap-color-black" data-color="black"></div>
                </div>

                <div class="instructions">
                    <h3>ä¿å­˜å›¾ç‰‡</h3>
                    <p>åœ¨æ‰‹æœºä¸Šï¼šé•¿æŒ‰å›¾ç‰‡é€‰æ‹©"ä¿å­˜å›¾åƒ"</p>
                    <p>åœ¨ç”µè„‘ä¸Šï¼šå³é”®ç‚¹å‡»å›¾ç‰‡é€‰æ‹©"å¦å­˜ä¸º"</p>
                </div>
            </div>
        </div>

        <footer>
            <p>Â© 2025 æ™ºèƒ½å›¾ç‰‡åˆ‡å›¾å·¥å…· | æ‰€æœ‰å›¾ç‰‡å¤„ç†å‡åœ¨æœ¬åœ°å®Œæˆï¼Œä¸ä¼šä¸Šä¼ åˆ°æœåŠ¡å™¨</p>
        </footer>

    <script>
        // å…¨å±€å˜é‡
        let originalImage = null;
        let cropCanvas = null;
        let cropCtx = null;
        let targetAspectRatio = 0;
        let isDragging = false;
        let isResizing = false;
        let resizeHandle = null;
        let dragStart = {x: 0, y: 0};
        let currentRect = {x: 0, y: 0, width: 0, height: 0};
        let gridInfo = {rows: 3, cols: 2, ratio: 30, gapColor: 'white'};
        let cropContainer = null;

        // DOM å…ƒç´ 
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const selectBtn = document.getElementById('selectBtn');
        const processBtn = document.getElementById('processBtn');
        const cropBtn = document.getElementById('cropBtn');
        const rowsInput = document.getElementById('rows');
        const colsInput = document.getElementById('cols');
        const ratioInput = document.getElementById('ratio');
        const resultContainer = document.getElementById('resultContainer');
        const cropCanvasElement = document.getElementById('cropCanvas');
        const gapColorBtns = document.querySelectorAll('.gap-color-btn');

        // åˆå§‹åŒ–
        cropCanvas = cropCanvasElement;
        cropCtx = cropCanvas.getContext('2d');
        cropContainer = document.getElementById('cropContainer');

        // äº‹ä»¶ç›‘å¬å™¨
        fileInput.addEventListener('change', handleImageUpload);
        uploadArea.addEventListener('click', () => fileInput.click()); // æ•´ä¸ªåŒºåŸŸå¯ç‚¹å‡»ä¸Šä¼ 
        uploadArea.addEventListener('dragover', handleDragOver);
        uploadArea.addEventListener('drop', handleDrop);
        processBtn.addEventListener('click', processImage);
        cropBtn.addEventListener('click', generateResult);

        // ç¼éš™é¢œè‰²åˆ‡æ¢
        gapColorBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                gapColorBtns.forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                gridInfo.gapColor = this.dataset.color;
                updateResultGrid();
            });
        });

        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    processBtn.disabled = false;
                    uploadArea.innerHTML = `<img src="${event.target.result}" style="max-width:100%; max-height:200px; border-radius:10px;">`;
                    // é‡æ–°ç»‘å®šç‚¹å‡»äº‹ä»¶
                    uploadArea.addEventListener('click', () => fileInput.click());
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        // å¤„ç†æ‹–æ‹½ä¸Šä¼ 
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            uploadArea.style.borderColor = '#8a2be2';
            uploadArea.style.backgroundColor = 'rgba(200, 200, 255, 0.4)';
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            uploadArea.style.borderColor = '#4a00e0';
            uploadArea.style.backgroundColor = 'rgba(230, 230, 255, 0.2)';

            const file = e.dataTransfer.files[0];
            if (!file || !file.type.match('image.*')) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    processBtn.disabled = false;
                    uploadArea.innerHTML = `<img src="${event.target.result}" style="max-width:100%; max-height:200px; border-radius:10px;">`;
                    // é‡æ–°ç»‘å®šç‚¹å‡»äº‹ä»¶
                    uploadArea.addEventListener('click', () => fileInput.click());
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        // å¤„ç†å›¾ç‰‡ - è®¡ç®—æ¯”ä¾‹å¹¶æ˜¾ç¤ºè£å‰ªç•Œé¢
        function processImage() {
            if (!originalImage) {
                alert('è¯·å…ˆä¸Šä¼ å›¾ç‰‡');
                return;
            }

            gridInfo.rows = parseInt(rowsInput.value) || 3;
            gridInfo.cols = parseInt(colsInput.value) || 2;
            gridInfo.ratio = parseInt(ratioInput.value) || 30;

            // å¤„ç†æ— ç¼æƒ…å†µ
            if (gridInfo.ratio === 0) {
                targetAspectRatio = gridInfo.cols / gridInfo.rows;
            } else {
                // è®¡ç®—ç›®æ ‡é•¿å®½æ¯”
                const horizontal = gridInfo.cols * gridInfo.ratio + (gridInfo.cols - 1);
                const vertical = gridInfo.rows * gridInfo.ratio + (gridInfo.rows - 1);
                targetAspectRatio = horizontal / vertical;
            }

            // è®¾ç½®ç”»å¸ƒå°ºå¯¸ - ä½¿ç”¨ç›¸å¯¹å€¼ï¼Œç¡®ä¿åœ¨å®¹å™¨å†…
            const containerWidth = cropContainer.clientWidth;
            const containerHeight = Math.min(cropContainer.clientHeight, window.innerHeight * 0.6);

            let canvasWidth = originalImage.width;
            let canvasHeight = originalImage.height;

            // ä¿æŒåŸå§‹æ¯”ä¾‹ï¼Œä½†é™åˆ¶åœ¨å®¹å™¨å†…
            if (canvasWidth > containerWidth || canvasHeight > containerHeight) {
                const ratioW = containerWidth / canvasWidth;
                const ratioH = containerHeight / canvasHeight;
                const scale = Math.min(ratioW, ratioH);
                canvasWidth = Math.floor(canvasWidth * scale);
                canvasHeight = Math.floor(canvasHeight * scale);
            }

            // ç¡®ä¿æœ€å°å°ºå¯¸
            canvasWidth = Math.max(canvasWidth, 300);
            canvasHeight = Math.max(canvasHeight, 300);

            cropCanvas.width = canvasWidth;
            cropCanvas.height = canvasHeight;

            // ç»˜åˆ¶åŸå§‹å›¾ç‰‡
            cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropCtx.drawImage(originalImage, 0, 0, canvasWidth, canvasHeight);

            // åˆå§‹åŒ–è£å‰ªåŒºåŸŸï¼ˆå±…ä¸­ï¼Œä¿æŒç›®æ ‡æ¯”ä¾‹ï¼‰
            let cropWidth, cropHeight;
            if (gridInfo.ratio === 0) {
                // æ— ç¼æƒ…å†µç‰¹æ®Šå¤„ç†
                cropWidth = Math.min(canvasWidth, canvasHeight * targetAspectRatio);
                cropHeight = cropWidth / targetAspectRatio;
            } else {
                cropWidth = Math.min(canvasWidth, canvasHeight * targetAspectRatio);
                cropHeight = cropWidth / targetAspectRatio;
            }

            // ç¡®ä¿æœ€å°è£å‰ªå°ºå¯¸
            const minSize = 100;
            if (cropWidth < minSize) {
                cropWidth = minSize;
                cropHeight = minSize / targetAspectRatio;
            }
            if (cropHeight < minSize) {
                cropHeight = minSize;
                cropWidth = minSize * targetAspectRatio;
            }

            currentRect = {
                x: (canvasWidth - cropWidth) / 2,
                y: (canvasHeight - cropHeight) / 2,
                width: cropWidth,
                height: cropHeight
            };

            // ä¿®å¤è¶…å‡ºè¾¹ç•Œé—®é¢˜
            if (currentRect.x < 0) currentRect.x = 0;
            if (currentRect.y < 0) currentRect.y = 0;
            if (currentRect.x + currentRect.width > canvasWidth) {
                currentRect.width = canvasWidth - currentRect.x;
            }
            if (currentRect.y + currentRect.height > canvasHeight) {
                currentRect.height = canvasHeight - currentRect.y;
            }

            drawCropRect();
            cropBtn.disabled = false;

            // åˆ›å»ºæˆ–æ›´æ–°è£å‰ªæ‰‹æŸ„
            createResizeHandles();
        }

        // åˆ›å»ºè£å‰ªæ‰‹æŸ„
        function createResizeHandles() {
            // ç§»é™¤ç°æœ‰çš„æ‰‹æŸ„
            const existingHandles = cropContainer.querySelectorAll('.resize-handle');
            existingHandles.forEach(handle => handle.remove());

            // åˆ›å»ºå››ä¸ªæ‰‹æŸ„
            const positions = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
            positions.forEach(pos => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${pos}`;
                handle.dataset.handle = pos;
                cropContainer.appendChild(handle);

                // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
                handle.addEventListener('mousedown', startResize);
                handle.addEventListener('touchstart', startResize);
            });

            updateHandlesPosition();
        }

        // æ›´æ–°æ‰‹æŸ„ä½ç½®
        function updateHandlesPosition() {
            const handles = cropContainer.querySelectorAll('.resize-handle');
            handles.forEach(handle => {
                const rect = cropCanvas.getBoundingClientRect();
                const containerRect = cropContainer.getBoundingClientRect();

                const x = currentRect.x + rect.left - containerRect.left;
                const y = currentRect.y + rect.top - containerRect.top;
                const width = currentRect.width;
                const height = currentRect.height;

                if (handle.classList.contains('top-left')) {
                    handle.style.left = (x - 6) + 'px';
                    handle.style.top = (y - 6) + 'px';
                } else if (handle.classList.contains('top-right')) {
                    handle.style.right = (containerRect.width - (x + width) - 6) + 'px';
                    handle.style.top = (y - 6) + 'px';
                } else if (handle.classList.contains('bottom-left')) {
                    handle.style.left = (x - 6) + 'px';
                    handle.style.bottom = (containerRect.height - (y + height) - 6) + 'px';
                } else if (handle.classList.contains('bottom-right')) {
                    handle.style.right = (containerRect.width - (x + width) - 6) + 'px';
                    handle.style.bottom = (containerRect.height - (y + height) - 6) + 'px';
                }
            });
        }

        // ç»˜åˆ¶è£å‰ªåŒºåŸŸå’Œç½‘æ ¼é¢„è§ˆ
        function drawCropRect() {
            // é‡æ–°ç»˜åˆ¶åŸå§‹å›¾ç‰‡
            cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropCtx.drawImage(originalImage, 0, 0, cropCanvas.width, cropCanvas.height);

            // è£å‰ªåŒºåŸŸè¾¹æ¡†ï¼ˆè™šçº¿ï¼‰
            cropCtx.strokeStyle = '#4a00e0';
            cropCtx.lineWidth = 2;
            cropCtx.setLineDash([10, 5]);
            cropCtx.strokeRect(
                currentRect.x,
                currentRect.y,
                currentRect.width,
                currentRect.height
            );
            cropCtx.setLineDash([]);

            // ç»˜åˆ¶ç½‘æ ¼é¢„è§ˆ
            if (currentRect.width > 0 && currentRect.height > 0 && gridInfo.ratio !== 0) {
                // è®¡ç®—æ¯ä¸ªå•å…ƒæ ¼çš„å°ºå¯¸å’Œç¼éš™
                const totalHorizontal = gridInfo.cols * gridInfo.ratio + (gridInfo.cols - 1);
                const totalVertical = gridInfo.rows * gridInfo.ratio + (gridInfo.rows - 1);
                const cellWidth = (currentRect.width / totalHorizontal) * gridInfo.ratio;
                const cellHeight = (currentRect.height / totalVertical) * gridInfo.ratio;
                const gap = currentRect.width / totalHorizontal; // æ°´å¹³ç¼éš™

                cropCtx.strokeStyle = 'rgba(74, 0, 224, 0.5)';
                cropCtx.lineWidth = 1;
                cropCtx.setLineDash([3, 3]);

                // ç»˜åˆ¶æ‰€æœ‰å‚ç›´å‚è€ƒçº¿ï¼ˆåŒ…æ‹¬å•å…ƒæ ¼è¾¹ç•Œå’Œç¼éš™è¾¹ç•Œï¼‰
                let xPos = currentRect.x;
                for (let col = 0; col < gridInfo.cols; col++) {
                    // å•å…ƒæ ¼å³è¾¹ç•Œ
                    xPos += cellWidth;
                    cropCtx.beginPath();
                    cropCtx.moveTo(xPos, currentRect.y);
                    cropCtx.lineTo(xPos, currentRect.y + currentRect.height);
                    cropCtx.stroke();

                    // ç¼éš™å³è¾¹ç•Œï¼ˆé™¤äº†æœ€åä¸€åˆ—ï¼‰
                    if (col < gridInfo.cols - 1) {
                        xPos += gap;
                        cropCtx.beginPath();
                        cropCtx.moveTo(xPos, currentRect.y);
                        cropCtx.lineTo(xPos, currentRect.y + currentRect.height);
                        cropCtx.stroke();
                    }
                }

                // ç»˜åˆ¶æ‰€æœ‰æ°´å¹³å‚è€ƒçº¿ï¼ˆåŒ…æ‹¬å•å…ƒæ ¼è¾¹ç•Œå’Œç¼éš™è¾¹ç•Œï¼‰
                let yPos = currentRect.y;
                for (let row = 0; row < gridInfo.rows; row++) {
                    // å•å…ƒæ ¼ä¸‹è¾¹ç•Œ
                    yPos += cellHeight;
                    cropCtx.beginPath();
                    cropCtx.moveTo(currentRect.x, yPos);
                    cropCtx.lineTo(currentRect.x + currentRect.width, yPos);
                    cropCtx.stroke();

                    // ç¼éš™ä¸‹è¾¹ç•Œï¼ˆé™¤äº†æœ€åä¸€è¡Œï¼‰
                    if (row < gridInfo.rows - 1) {
                        yPos += gap;
                        cropCtx.beginPath();
                        cropCtx.moveTo(currentRect.x, yPos);
                        cropCtx.lineTo(currentRect.x + currentRect.width, yPos);
                        cropCtx.stroke();
                    }
                }

                cropCtx.setLineDash([]);
            } else if (currentRect.width > 0 && currentRect.height > 0 && gridInfo.ratio === 0) {
                // æ— ç¼æƒ…å†µ - åªç»˜åˆ¶å•å…ƒæ ¼è¾¹ç•Œ
                cropCtx.strokeStyle = 'rgba(74, 0, 224, 0.5)';
                cropCtx.lineWidth = 1;
                cropCtx.setLineDash([3, 3]);

                // å‚ç›´çº¿
                for (let i = 1; i < gridInfo.cols; i++) {
                    const x = currentRect.x + (currentRect.width / gridInfo.cols) * i;
                    cropCtx.beginPath();
                    cropCtx.moveTo(x, currentRect.y);
                    cropCtx.lineTo(x, currentRect.y + currentRect.height);
                    cropCtx.stroke();
                }

                // æ°´å¹³çº¿
                for (let i = 1; i < gridInfo.rows; i++) {
                    const y = currentRect.y + (currentRect.height / gridInfo.rows) * i;
                    cropCtx.beginPath();
                    cropCtx.moveTo(currentRect.x, y);
                    cropCtx.lineTo(currentRect.x + currentRect.width, y);
                    cropCtx.stroke();
                }

                cropCtx.setLineDash([]);
            }

            // æ›´æ–°æ‰‹æŸ„ä½ç½®
            updateHandlesPosition();
        }

        // é¼ æ ‡äº‹ä»¶å¤„ç† - æ‹–åŠ¨
        function startDrag(e) {
            const rect = cropCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // æ£€æŸ¥æ˜¯å¦åœ¨è£å‰ªåŒºåŸŸå†…
            if (x >= currentRect.x && x <= currentRect.x + currentRect.width &&
                y >= currentRect.y && y <= currentRect.y + currentRect.height) {
                isDragging = true;
                dragStart.x = x - currentRect.x;
                dragStart.y = y - currentRect.y;
                cropCanvas.style.cursor = 'move';
                e.preventDefault();
            }
        }

        function doDrag(e) {
            if (!isDragging) return;

            const rect = cropCanvas.getBoundingClientRect();
            let x = e.clientX - rect.left - dragStart.x;
            let y = e.clientY - rect.top - dragStart.y;

            // é™åˆ¶åœ¨ç”»å¸ƒèŒƒå›´å†…
            x = Math.max(0, Math.min(x, cropCanvas.width - currentRect.width));
            y = Math.max(0, Math.min(y, cropCanvas.height - currentRect.height));

            currentRect.x = x;
            currentRect.y = y;
            drawCropRect();
            e.preventDefault();
        }

        function endDrag() {
            isDragging = false;
            cropCanvas.style.cursor = 'default';
        }

        // è§¦æ‘¸äº‹ä»¶å¤„ç† - æ‹–åŠ¨
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = cropCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            if (x >= currentRect.x && x <= currentRect.x + currentRect.width &&
                y >= currentRect.y && y <= currentRect.y + currentRect.height) {
                isDragging = true;
                dragStart.x = x - currentRect.x;
                dragStart.y = y - currentRect.y;
            }
        }

        function handleTouchMove(e) {
            if (!isDragging) return;
            e.preventDefault();

            const touch = e.touches[0];
            const rect = cropCanvas.getBoundingClientRect();
            let x = touch.clientX - rect.left - dragStart.x;
            let y = touch.clientY - rect.top - dragStart.y;

            x = Math.max(0, Math.min(x, cropCanvas.width - currentRect.width));
            y = Math.max(0, Math.min(y, cropCanvas.height - currentRect.height));

            currentRect.x = x;
            currentRect.y = y;
            drawCropRect();
        }

        function handleTouchEnd(e) {
            isDragging = false;
        }

        // ç¼©æ”¾å¤„ç† - ä¿®å¤é•¿å®½æ¯”é—®é¢˜
        function startResize(e) {
            e.preventDefault();
            isResizing = true;
            resizeHandle = e.target.dataset.handle;
            dragStart.x = e.clientX || e.touches[0].clientX;
            dragStart.y = e.clientY || e.touches[0].clientY;
            cropCanvas.style.cursor = getResizeCursor(resizeHandle);
        }

        function doResize(e) {
            if (!isResizing) return;

            const rect = cropCanvas.getBoundingClientRect();
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            const deltaX = clientX - dragStart.x;
            const deltaY = clientY - dragStart.y;

            let newWidth = currentRect.width;
            let newHeight = currentRect.height;
            let newX = currentRect.x;
            let newY = currentRect.y;

            // æ ¹æ®æ‰‹æŸ„ä½ç½®è°ƒæ•´
            if (resizeHandle === 'bottom-right') {
                newWidth = currentRect.width + deltaX;
                newHeight = currentRect.height + deltaY;
            } else if (resizeHandle === 'bottom-left') {
                newWidth = currentRect.width - deltaX;
                newHeight = currentRect.height + deltaY;
                newX = currentRect.x + currentRect.width - newWidth;
            } else if (resizeHandle === 'top-right') {
                newWidth = currentRect.width + deltaX;
                newHeight = currentRect.height - deltaY;
                newY = currentRect.y + currentRect.height - newHeight;
            } else if (resizeHandle === 'top-left') {
                newWidth = currentRect.width - deltaX;
                newHeight = currentRect.height - deltaY;
                newX = currentRect.x + currentRect.width - newWidth;
                newY = currentRect.y + currentRect.height - newHeight;
            }

            // ä¿æŒæ¯”ä¾‹ï¼ˆéæ— ç¼æ¨¡å¼ï¼‰
            if (gridInfo.ratio !== 0) {
                // å…ˆæŒ‰æ¯”ä¾‹è°ƒæ•´
                if (resizeHandle === 'bottom-right' || resizeHandle === 'top-left') {
                    // ä¿æŒæ¯”ä¾‹ï¼Œä½¿ç”¨å®½åº¦è®¡ç®—é«˜åº¦
                    newHeight = newWidth / targetAspectRatio;
                    if (resizeHandle === 'top-left') {
                        newY = currentRect.y + currentRect.height - newHeight;
                    }
                } else {
                    // ä¿æŒæ¯”ä¾‹ï¼Œä½¿ç”¨é«˜åº¦è®¡ç®—å®½åº¦
                    newWidth = newHeight * targetAspectRatio;
                    if (resizeHandle === 'bottom-left' || resizeHandle === 'top-left') {
                        newX = currentRect.x + currentRect.width - newWidth;
                    }
                }

                // æ£€æŸ¥æ˜¯å¦è¶…å‡ºç”»å¸ƒè¾¹ç•Œï¼Œå¹¶è¿›è¡Œä¿®æ­£
                let corrected = false;

                // æ£€æŸ¥å³è¾¹ç•Œ
                if (newX + newWidth > cropCanvas.width) {
                    newWidth = cropCanvas.width - newX;
                    newHeight = newWidth / targetAspectRatio;
                    corrected = true;
                }

                // æ£€æŸ¥ä¸‹è¾¹ç•Œ
                if (newY + newHeight > cropCanvas.height) {
                    newHeight = cropCanvas.height - newY;
                    newWidth = newHeight * targetAspectRatio;
                    corrected = true;
                }

                // æ£€æŸ¥å·¦è¾¹ç•Œ
                if (newX < 0) {
                    newX = 0;
                    // é‡æ–°è®¡ç®—ä»¥ä¿æŒæ¯”ä¾‹
                    if (newX + newWidth > cropCanvas.width) {
                        newWidth = cropCanvas.width;
                        newHeight = newWidth / targetAspectRatio;
                    }
                    corrected = true;
                }

                // æ£€æŸ¥ä¸Šè¾¹ç•Œ
                if (newY < 0) {
                    newY = 0;
                    // é‡æ–°è®¡ç®—ä»¥ä¿æŒæ¯”ä¾‹
                    if (newY + newHeight > cropCanvas.height) {
                        newHeight = cropCanvas.height;
                        newWidth = newHeight * targetAspectRatio;
                    }
                    corrected = true;
                }

                // å¦‚æœç»è¿‡ä¿®æ­£ï¼Œå¯èƒ½éœ€è¦å†æ¬¡è°ƒæ•´ä½ç½®
                if (corrected) {
                    if (resizeHandle === 'bottom-left' || resizeHandle === 'top-left') {
                        newX = currentRect.x + currentRect.width - newWidth;
                        if (newX < 0) newX = 0;
                    }
                    if (resizeHandle === 'top-right' || resizeHandle === 'top-left') {
                        newY = currentRect.y + currentRect.height - newHeight;
                        if (newY < 0) newY = 0;
                    }
                }
            }

            // ç¡®ä¿æœ€å°å°ºå¯¸
            if (newWidth < 50) newWidth = 50;
            if (newHeight < 50) newHeight = 50;

            // æœ€ç»ˆè¾¹ç•Œæ£€æŸ¥
            if (newX < 0) newX = 0;
            if (newY < 0) newY = 0;
            if (newX + newWidth > cropCanvas.width) {
                newWidth = cropCanvas.width - newX;
            }
            if (newY + newHeight > cropCanvas.height) {
                newHeight = cropCanvas.height - newY;
            }

            currentRect = {x: newX, y: newY, width: newWidth, height: newHeight};
            drawCropRect();

            dragStart.x = clientX;
            dragStart.y = clientY;
        }

        function endResize() {
            isResizing = false;
            resizeHandle = null;
            cropCanvas.style.cursor = 'default';
        }

        function getResizeCursor(handle) {
            const cursors = {
                'top-left': 'nw-resize',
                'top-right': 'ne-resize',
                'bottom-left': 'sw-resize',
                'bottom-right': 'se-resize'
            };
            return cursors[handle] || 'default';
        }

        // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨åˆ°ç”»å¸ƒ
        cropCanvas.addEventListener('mousedown', startDrag);
        cropCanvas.addEventListener('mousemove', doDrag);
        cropCanvas.addEventListener('mouseup', endDrag);
        cropCanvas.addEventListener('mouseleave', endDrag);

        // è§¦æ‘¸äº‹ä»¶
        cropCanvas.addEventListener('touchstart', handleTouchStart);
        cropCanvas.addEventListener('touchmove', handleTouchMove);
        cropCanvas.addEventListener('touchend', handleTouchEnd);

        // ä¸ºæ•´ä¸ªå®¹å™¨æ·»åŠ äº‹ä»¶ç›‘å¬å™¨ï¼ˆç”¨äºç¼©æ”¾ï¼‰
        cropContainer.addEventListener('mousemove', (e) => {
            if (isResizing) doResize(e);
        });

        cropContainer.addEventListener('mouseup', endResize);
        cropContainer.addEventListener('mouseleave', endResize);

        cropContainer.addEventListener('touchmove', (e) => {
            if (isResizing) doResize(e);
        });

        cropContainer.addEventListener('touchend', endResize);

        // ç”Ÿæˆç»“æœ
        function generateResult() {
            if (!originalImage || !currentRect.width || !currentRect.height) {
                alert('è¯·å…ˆå¤„ç†å›¾ç‰‡å¹¶è°ƒæ•´è£å‰ªåŒºåŸŸ');
                return;
            }

            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            resultContainer.innerHTML = '<div class="loading"><div class="spinner"></div><p>æ­£åœ¨ç”Ÿæˆåˆ‡å›¾...</p></div>';

            // è®¡ç®—è£å‰ªåçš„å®é™…å°ºå¯¸
            const croppedCanvas = document.createElement('canvas');
            const croppedCtx = croppedCanvas.getContext('2d');

            // è®¡ç®—åŸå§‹è£å‰ªåŒºåŸŸåœ¨åŸå›¾ä¸­çš„å®é™…å°ºå¯¸
            const scaleX = originalImage.width / cropCanvas.width;
            const scaleY = originalImage.height / cropCanvas.height;
            const actualWidth = currentRect.width * scaleX;
            const actualHeight = currentRect.height * scaleY;

            croppedCanvas.width = actualWidth;
            croppedCanvas.height = actualHeight;
            croppedCtx.drawImage(
                originalImage,
                currentRect.x * scaleX,
                currentRect.y * scaleY,
                actualWidth,
                actualHeight,
                0, 0,
                actualWidth,
                actualHeight
            );

            // å¤„ç†æ— ç¼æƒ…å†µ
            let finalWidth, finalHeight, cellPixelSize, gapSize;

            if (gridInfo.ratio === 0) {
                // æ— ç¼è£åˆ‡
                cellPixelSize = Math.floor(Math.min(actualWidth / gridInfo.cols, actualHeight / gridInfo.rows));
                finalWidth = cellPixelSize * gridInfo.cols;
                finalHeight = cellPixelSize * gridInfo.rows;
                gapSize = 0;
            } else {
                // è®¡ç®—ç›®æ ‡ç½‘æ ¼å°ºå¯¸
                const cellSize = Math.min(
                    actualWidth / (gridInfo.cols * gridInfo.ratio + gridInfo.cols - 1),
                    actualHeight / (gridInfo.rows * gridInfo.ratio + gridInfo.rows - 1)
                );

                // ç¡®ä¿ cellSize æ˜¯æ•´æ•°
                const intCellSize = Math.max(1, Math.floor(cellSize));

                // è®¡ç®—æœ€ç»ˆç¼©æ”¾å°ºå¯¸
                finalWidth = intCellSize * (gridInfo.cols * gridInfo.ratio + gridInfo.cols - 1);
                finalHeight = intCellSize * (gridInfo.rows * gridInfo.ratio + gridInfo.rows - 1);
                cellPixelSize = intCellSize * gridInfo.ratio;
                gapSize = intCellSize;
            }

            // åˆ›å»ºæœ€ç»ˆç”»å¸ƒ
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = finalWidth;
            finalCanvas.height = finalHeight;
            const finalCtx = finalCanvas.getContext('2d');

            // å°†è£å‰ªåçš„å›¾ç‰‡ç¼©æ”¾åˆ°æœ€ç»ˆå°ºå¯¸
            finalCtx.drawImage(croppedCanvas, 0, 0, finalWidth, finalHeight);

            // åˆ›å»ºç»“æœå›¾ç‰‡
            const cellImages = [];

            for (let row = 0; row < gridInfo.rows; row++) {
                for (let col = 0; col < gridInfo.cols; col++) {
                    let x, y;

                    if (gridInfo.ratio === 0) {
                        x = col * cellPixelSize;
                        y = row * cellPixelSize;
                    } else {
                        x = col * (cellPixelSize + gapSize);
                        y = row * (cellPixelSize + gapSize);
                    }

                    // åˆ›å»ºå°ç”»å¸ƒ
                    const cellCanvas = document.createElement('canvas');
                    cellCanvas.width = cellPixelSize;
                    cellCanvas.height = cellPixelSize;
                    const cellCtx = cellCanvas.getContext('2d');

                    // ä»æœ€ç»ˆç”»å¸ƒä¸­æå–å•å…ƒæ ¼
                    cellCtx.drawImage(
                        finalCanvas,
                        x, y,
                        cellPixelSize, cellPixelSize,
                        0, 0,
                        cellPixelSize, cellPixelSize
                    );

                    // è½¬æ¢ä¸ºå›¾ç‰‡
                    const img = new Image();
                    img.src = cellCanvas.toDataURL('image/png');
                    cellImages.push(img);
                }
            }

            // æ˜¾ç¤ºç»“æœ
            displayResults(cellImages, cellPixelSize, gapSize);
        }

        // æ˜¾ç¤ºç»“æœå›¾ç‰‡ - ä½¿ç”¨ç›¸å¯¹æ¯”ä¾‹
        function displayResults(images, cellSize, gapSize) {
            resultContainer.innerHTML = '';

            // åˆ›å»ºç½‘æ ¼å®¹å™¨
            const grid = document.createElement('div');
            grid.className = 'result-grid';

            // è®¡ç®—aspect-ratioå’Œgapç™¾åˆ†æ¯”
            if (gridInfo.ratio === 0) {
                // æ— ç¼æ¨¡å¼
                grid.style.aspectRatio = `${gridInfo.cols}/${gridInfo.rows}`;
                grid.style.gap = "0%";
                grid.style.padding = "2.5%";
                grid.style.boxSizing = 'content-box';
                grid.style.gridTemplateColumns = `repeat(${gridInfo.cols}, 1fr)`;
                grid.style.gridTemplateRows = `repeat(${gridInfo.rows}, 1fr)`;
            } else {
                // æœ‰ç¼æ¨¡å¼
                const horizontalTotal = gridInfo.cols * gridInfo.ratio + (gridInfo.cols - 1);
                const verticalTotal = gridInfo.rows * gridInfo.ratio + (gridInfo.rows - 1);

                grid.style.aspectRatio = `${horizontalTotal}/${verticalTotal}`;

                // è®¡ç®—gapç™¾åˆ†æ¯”
                const horizontalGapPercent = (1 / horizontalTotal * 100);
                const verticalGapPercent = (1 / verticalTotal * 100);

                grid.style.gap = `${verticalGapPercent}% ${horizontalGapPercent}%`;
                grid.style.padding = `${horizontalGapPercent}%`;
                grid.style.boxSizing = 'content-box';
                grid.style.gridTemplateColumns = `repeat(${gridInfo.cols}, 1fr)`;
                grid.style.gridTemplateRows = `repeat(${gridInfo.rows}, 1fr)`;
            }

            grid.style.setProperty('--gap-color', gridInfo.gapColor === 'white' ? '#ffffff' : '#000000');

            // æ·»åŠ å›¾ç‰‡åˆ°ç½‘æ ¼
            images.forEach(img => {
                const cell = document.createElement('div');
                img.className = 'result-image';
                cell.appendChild(img);
                cell.classList.add('result-cell');
                grid.appendChild(cell);
            });

            resultContainer.appendChild(grid);
            resultContainer.style.overflow = 'auto';
        }

        // æ›´æ–°ç»“æœç½‘æ ¼çš„ç¼éš™é¢œè‰²
        function updateResultGrid() {
            const grid = resultContainer.querySelector('.result-grid');
            if (grid) {
                grid.style.setProperty('--gap-color', gridInfo.gapColor === 'white' ? '#ffffff' : '#000000');
            }
        }

        // çª—å£å¤§å°è°ƒæ•´æ—¶é‡æ–°ç»˜åˆ¶
        window.addEventListener('resize', () => {
            if (originalImage && currentRect.width > 0) {
                processImage();
            }
        });
    </script>
</body>
</html>

